package tech.projectmatris.antimalwareapp.scanners

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.os.Build
import android.preference.PreferenceManager
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import io.reactivex.Observable
import io.reactivex.Scheduler
import io.reactivex.Single
import io.reactivex.android.schedulers.AndroidSchedulers
import io.reactivex.schedulers.Schedulers
import io.reactivex.subjects.PublishSubject
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import org.tensorflow.lite.Interpreter
import org.xmlpull.v1.XmlPullParser
import tech.projectmatris.antimalwareapp.R
import tech.projectmatris.antimalwareapp.appextension.AppExtensionState
import tech.projectmatris.antimalwareapp.appextension.ExtensionUtils
import tech.projectmatris.antimalwareapp.data.AppInfo
import java.io.FileInputStream
import java.io.IOException
import java.lang.ref.WeakReference
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel
import java.nio.charset.Charset
import java.text.DateFormat
import java.util.*
import kotlin.collections.ArrayList

 class ScanTaskInteractor {
    var withSysApps = false

    var contextReference: WeakReference<Context>? = null
    val context: Context? get() = contextReference?.get()

    private var tflite: Interpreter? = null
    private var p_jArray: JSONArray? = null
    private var i_jArray: JSONArray? = null
    private val goodware = ArrayList<AppInfo>()
    private val malware = ArrayList<AppInfo>()
    private val unknown = ArrayList<AppInfo>()
    private val risky = ArrayList<AppInfo>()
    private val scannedApps = ArrayList<AppInfo>()

    private var installedAppsCount = 0
    private var progressValue = 0

    private var notificationManager: NotificationManagerCompat? = null
    private val NOTIFICATION_ID = 100

    var sharedPreferences: SharedPreferences? = null
    var editor: SharedPreferences.Editor? = null

    fun scan(): Single<ArrayList<AppInfo>> {
        return Single
            .fromCallable {
                context?.let {
                    sharedPreferences = PreferenceManager.getDefaultSharedPreferences(it)
                }
                sharedPreferences?.edit()?.apply {
                    putString(ExtensionUtils.WORK_STATUS, AppExtensionState.START.id)
                    apply()
                }

                val uri = ExtensionUtils.getContentUri(AppExtensionState.START.id)
                context?.contentResolver?.insert(uri, null)

                val inputVal = FloatArray(2000)
                try {
                    loadModelFile()?.let { buffer ->
                        tflite = Interpreter(buffer, null)
                    }
                } catch (ex: Exception) {
                    ex.printStackTrace()
                }

                try {
                    // Loading the features.json from assets folder. Refer loadJSONFromAsset() function for more details
                    val obj = JSONObject(loadJSONFromAsset())
                    p_jArray =
                        obj.getJSONArray("permissions") // This array stores permissions from features.json file
                    i_jArray =
                        obj.getJSONArray("intents") // This array  stores intents from features.json file
                } catch (e: JSONException) {
                    e.printStackTrace()
                }
                inputVal
            }
            .map { inputVal -> observeScan(inputVal) }
            .map {
                onScanFinished()
            }
            .doOnSubscribe {
                doOnSubscribe()
            }
            .doAfterTerminate {
                cancelScanNotification()
            }
    }

    fun cancelScanNotification() {
        val CHANNEL_ID = "channel_100"
       notificationManager?.deleteNotificationChannel(CHANNEL_ID)
        notificationManager?.cancel(NOTIFICATION_ID)
    }

    private fun observeScan(inputVal: FloatArray) {
        val packageManager = context?.packageManager
        packageManager
            ?.getInstalledApplications(PackageManager.GET_META_DATA)
            ?.let { packages ->
                val pt = packages //+ packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages + packages
                for (packageInfo in pt) {
                    var flag = false
                    // flag is true if and only if the app under scan contains at least one permission or intent-filter defined in features.json
                    val scanningAppName = packageInfo.loadLabel(packageManager).toString()
                    onScanProgress(scanningAppName)

                    val app = AppInfo(
                        packageInfo.loadLabel(packageManager).toString(),
                        packageInfo.packageName,
                        packageInfo.publicSourceDir,
                        packageInfo.flags and ApplicationInfo.FLAG_SYSTEM
                    )

                    app.appIcon = packageInfo.loadIcon(packageManager)
                    if (true) {
                        //   if (packageInfo.flags and ApplicationInfo.FLAG_SYSTEM != 1 || withSysApps) {
                        Log.d(
                            "TestB",
                            "packageInfo: ${packageInfo.flags} -- ${ApplicationInfo.FLAG_SYSTEM} -- $withSysApps"
                        )
                        try {
                            //count++;
                            // Get the list of permissions used by the application.
                            //Log.d(TAG,"extracting permissions...");
                            //long startTime = System.currentTimeMillis();
                            context?.let { context ->
                                context.createPackageContext(packageInfo.packageName, 0)
                                val appPermissionsList = getListOfPermissions(context)

                                // Get the list of intents used by the application.
                                //Log.d(TAG,"extracting intents...");
                                val appIntentsList = getListOfIntents(
                                    context.createPackageContext(
                                        packageInfo.packageName,
                                        0
                                    )
                                )
                                var str: String
                                //Log.d(scanningAppName,"IntentsList: "+appIntentsList.get(0));
                                //Log.d(scanningAppName,"IntentsList size: "+appIntentsList.size());
                                if (appPermissionsList.size == 0 && appIntentsList.size == 0) {
                                    //Log.d(TAG,"No permissions and intents found. Skipping...");
                                    app.prediction =
                                        context.getString(R.string.unknown)
                                    unknown.add(app)
                                }

                                // The following for loops are used to create the input feature vector
                                p_jArray?.let { jsonArray ->
                                    for (i in 0 until jsonArray.length()) {
                                        str = jsonArray.optString(i)
                                        if (appPermissionsList.contains(str)) {
                                            inputVal[i] = 1f
                                            flag = true
                                            //Log.d(scanningAppName,"Check Permissions: "+ str + " is present in appsPermissionsList.");
                                        } else {
                                            inputVal[i] = 0f
                                            ///Log.d(scanningAppName,"Check Permissions: "+ str + " is NOT present in appsPermissionsList.");
                                        }
                                    }
                                }
                                i_jArray?.let { jsonArray ->
                                    for (i in 0 until jsonArray.length()) {
                                        str = jsonArray.optString(i)
                                        if (appIntentsList.contains(str)) {
                                            inputVal[i + 489] = 1f
                                            flag = true
                                            //Log.d(scanningAppName,"Check Intents:"+ str + " is present in appsIntentsList.");
                                        } else {
                                            inputVal[i + 489] = 0f
                                            //Log.d(scanningAppName,"Check Intents:"+ str + " is NOT present in appsIntentsList.");
                                        }
                                    }
                                }
                                //Log.d("Info:", "feature vector is created.");
                                //Log.d(scanningAppName, scanningAppName+" feature vector:"+ Arrays.toString(inputVal));
                                if (!flag) {
                                    app.prediction =
                                        contextReference!!.get()!!
                                            .getString(R.string.unknown)
                                    unknown.add(app)
                                }

                                // To store output from the model
                                val outputVal = Array(1) { FloatArray(1) }

                                // Run the model
                                tflite?.run(inputVal, outputVal)

                                //long endTime = System.currentTimeMillis();
                                //elapsedTime = endTime - startTime;
                                //totalTime += elapsedTime;
                                //Log.d(TIMER, "Elapsed Time: " + Float.toString(elapsedTime));
                                val inferredValue = outputVal[0][0]
                                app.predictionScore = inferredValue
                                app.permissionList = appPermissionsList
                                when {
                                    inferredValue > 0.75 -> {
                                        app.prediction =
                                            contextReference!!.get()!!
                                                .getString(R.string.malware)
                                        malware.add(app)
                                    }
                                    inferredValue > 0.5 -> {
                                        app.prediction =
                                            contextReference!!.get()!!
                                                .getString(R.string.risky)
                                        risky.add(app)
                                    }
                                    else -> {
                                        app.prediction =
                                            contextReference!!.get()!!
                                                .getString(R.string.safe)
                                        goodware.add(app)
                                    }
                                }
                            }
                        } catch (e: PackageManager.NameNotFoundException) {
                            e.printStackTrace()
                        }
                    }
                }
            }
    }

    private fun doOnSubscribe() {
        context?.let { context ->
            installedAppsCount = context.packageManager.getInstalledApplications(0).size
            notificationManager = NotificationManagerCompat.from(context)
            val CHANNEL_ID = "channel_100"
            val notificationBuilder =
                NotificationCompat.Builder(context, CHANNEL_ID)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val CHANNEL_NAME = "PROJECT MATRIS"
                val mChannel =
                    NotificationChannel(
                        CHANNEL_ID,
                        CHANNEL_NAME,
                        NotificationManager.IMPORTANCE_HIGH
                    )
            notificationManager?.createNotificationChannel(mChannel)
            }
            notificationBuilder.setSmallIcon(R.mipmap.ic_launcher_round)
                .setOngoing(true)
                .setContentTitle("Full Antivirus")
                .setContentText(contextReference!!.get()!!.getString(R.string.scanningApplications))
                .setProgress(0, 0, true)
            notificationManager?.notify(NOTIFICATION_ID, notificationBuilder.build())
        }
    }

    private fun onScanFinished(): ArrayList<AppInfo> {
        sharedPreferences
            ?.edit()
            ?.apply {
                putString(ExtensionUtils.WORK_STATUS, AppExtensionState.STOP.id)
                apply()
            }
        putDateInSharedPreference()

        val uri = ExtensionUtils.getContentUri(AppExtensionState.STOP.id)
        context?.contentResolver?.insert(uri, null)

        Collections.sort(malware, AppInfo.appNameComparator)
        Collections.sort(risky, AppInfo.appNameComparator)
        Collections.sort(unknown, AppInfo.appNameComparator)
        Collections.sort(goodware, AppInfo.appNameComparator)
        scannedApps.addAll(malware)
        scannedApps.addAll(risky)
        scannedApps.addAll(unknown)
        scannedApps.addAll(goodware)

        notificationManager?.cancel(NOTIFICATION_ID)
        return scannedApps
    }


    var onScanProgressChangedListener: OnScanProgressChangedListener? = null
    var scanProgressInfo: ScanProgressInfo = ScanProgressInfo("", "", 0, 0)

    var mObservable = PublishSubject.create<ScanProgressInfo>()

    private fun onScanProgress(scanStatus: String) {


        progressValue += 1
        val percentCompleted = (progressValue.toFloat() / installedAppsCount * 100f).toInt()
        // val progressUri = ExtensionUtils.getProgressContentUri(percentCompleted.toString())
        // context?.contentResolver?.insert(progressUri, null)
        Log.d(
            "TestB",
            "progressPublishSubject ${Thread.currentThread()}$scanStatus $percentCompleted $progressValue $installedAppsCount"
        )
        val scanProgressInfo = ScanProgressInfo(
            scanStatus,
            String.format("%d of %d", progressValue, installedAppsCount),
            progressValue,
            percentCompleted
        )
        mObservable.onNext(scanProgressInfo)
    }

    private fun loadJSONFromAsset(): String? {
        return try {
            val jsonAsset = contextReference!!.get()!!.assets.open("features.json")
            val size = jsonAsset.available()
            val buffer = ByteArray(size)
            jsonAsset.read(buffer)
            jsonAsset.close()
            String(buffer, Charset.forName("UTF-8"))
        } catch (ex: IOException) {
            ex.printStackTrace()
            return null
        }
    }

    private fun loadModelFile(): MappedByteBuffer? {
        return try {
            context?.assets?.openFd("saved_model.tflite")?.let { fileDescriptor ->
                val inputStream = FileInputStream(fileDescriptor.fileDescriptor)
                val fileChannel = inputStream.channel
                val startOffset = fileDescriptor.startOffset
                val declaredLength = fileDescriptor.declaredLength
                fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength)
            }
        } catch (exception: Exception) {
            exception.printStackTrace()
            null
        }
    }

    private fun getListOfPermissions(context: Context): ArrayList<String> {
        val arr = ArrayList<String>()
        try {
            val am = context.createPackageContext(context.packageName, 0).assets
            val addAssetPath = am.javaClass.getMethod(
                "addAssetPath",
                String::class.java
            )
            val cookie = addAssetPath.invoke(
                am,
                context.packageManager.getApplicationInfo(context.packageName, 0).sourceDir
            ) as Int
            val xmlParser = am.openXmlResourceParser(cookie, "AndroidManifest.xml")
            var eventType = xmlParser.next()
            while (eventType != XmlPullParser.END_DOCUMENT) {
                if (eventType == XmlPullParser.START_TAG && "uses-permission" == xmlParser.name) {
                    for (i in 0 until xmlParser.attributeCount) {
                        if (xmlParser.getAttributeName(i) == "name") {
                            arr.add(xmlParser.getAttributeValue(i))
                        }
                    }
                }
                eventType = xmlParser.next()
            }
            xmlParser.close()
        } catch (exception: Exception) {
            exception.printStackTrace()
        }
        return arr
    }

    private fun getListOfIntents(context: Context): ArrayList<String> {
        val arr = ArrayList<String>()
        try {
            val am = context.createPackageContext(context.packageName, 0).assets
            val addAssetPath = am.javaClass.getMethod(
                "addAssetPath",
                String::class.java
            )
            val cookie = addAssetPath.invoke(
                am,
                context.packageManager.getApplicationInfo(context.packageName, 0).sourceDir
            ) as Int
            val xmlParser = am.openXmlResourceParser(cookie, "AndroidManifest.xml")
            var eventType = xmlParser.next()
            while (eventType != XmlPullParser.END_DOCUMENT) {
                if (eventType == XmlPullParser.START_TAG && "action" == xmlParser.name) {
                    for (i in 0 until xmlParser.attributeCount) {
                        if (xmlParser.getAttributeName(i) == "name") {
                            arr.add(xmlParser.getAttributeValue(i))
                        }
                    }
                }
                eventType = xmlParser.next()
            }
            xmlParser.close()
        } catch (exception: Exception) {
            exception.printStackTrace()
        }
        return arr
    }

    private fun putDateInSharedPreference() {
        sharedPreferences
            ?.edit()
            ?.apply {
                val curDateTime = DateFormat.getDateTimeInstance().format(Date())
                putString("lastScan", curDateTime)
                apply()
            }
    }
}