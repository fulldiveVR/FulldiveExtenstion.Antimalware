package tech.projectmatris.antimalwareapp.scanners

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.SharedPreferences
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.os.Build
import android.preference.PreferenceManager
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import io.reactivex.Single
import io.reactivex.subjects.PublishSubject
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import org.tensorflow.lite.Interpreter
import org.xmlpull.v1.XmlPullParser
import tech.projectmatris.antimalwareapp.R
import tech.projectmatris.antimalwareapp.appextension.AppExtensionState
import tech.projectmatris.antimalwareapp.appextension.ExtensionUtils
import tech.projectmatris.antimalwareapp.data.AppInfo
import java.io.FileInputStream
import java.io.IOException
import java.lang.ref.WeakReference
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel
import java.nio.charset.Charset
import java.text.DateFormat
import java.util.*
import kotlin.collections.ArrayList

class ScannerTask {
    var withSysApps = false

    var contextReference: WeakReference<Context>? = null
    val context: Context? get() = contextReference?.get()

    private var tflite: Interpreter? = null
    private var pJarray: JSONArray? = null
    private var iJarray: JSONArray? = null

    private val goodware = ArrayList<AppInfo>()
    private val malware = ArrayList<AppInfo>()
    private val unknown = ArrayList<AppInfo>()
    private val risky = ArrayList<AppInfo>()
    private val scannedApps = ArrayList<AppInfo>()

    private var installedAppsCount = 0
    private var progressValue = 0

    private var notificationManager: NotificationManagerCompat? = null
    private var sharedPreferences: SharedPreferences? = null

    fun scan(): Single<ArrayList<AppInfo>> {
        return Single
            .fromCallable {
                context?.let {
                    sharedPreferences = PreferenceManager.getDefaultSharedPreferences(it)
                }
                sharedPreferences?.edit()?.apply {
                    putString(ExtensionUtils.WORK_STATUS, AppExtensionState.START.id)
                    apply()
                }

                val uri = ExtensionUtils.getContentUri(AppExtensionState.START.id)
                context?.contentResolver?.insert(uri, null)

                val inputVal = FloatArray(2000)
                try {
                    loadModelFile()?.let { buffer ->
                        tflite = Interpreter(buffer, null)
                    }
                } catch (ex: Exception) {
                    ex.printStackTrace()
                }

                try {
                    // Loading the features.json from assets folder. Refer loadJSONFromAsset() function for more details
                    val obj = JSONObject(loadJSONFromAsset())
                    pJarray = obj.getJSONArray("permissions")
                    // This array stores permissions from features.json file
                    iJarray = obj.getJSONArray("intents")
                    // This array  stores intents from features.json file
                } catch (e: JSONException) {
                    e.printStackTrace()
                }
                scanApps(inputVal)
            }
            .map {
                mapToScannedApps()
            }
            .doOnSubscribe {
                doOnSubscribe()
            }
            .doAfterTerminate {
                cancelNotifications()
            }
    }

    fun cancelNotifications() {
        notificationManager?.deleteNotificationChannel(ScannerTaskConstants.CHANNEL_ID)
        notificationManager?.cancel(ScannerTaskConstants.NOTIFICATION_ID)
    }

    private fun scanApps(inputVal: FloatArray) {
        val packageManager = context?.packageManager
        packageManager
            ?.getInstalledApplications(PackageManager.GET_META_DATA)
            ?.let { packages ->
                for (packageInfo in packages) {
                    var flag = false
                    // flag is true if and only if the app under scan contains at least one permission or intent-filter defined in features.json
                    val scanningAppName = packageInfo.loadLabel(packageManager).toString()
                    onScanProgress(scanningAppName)

                    val app = AppInfo(
                        packageInfo.loadLabel(packageManager).toString(),
                        packageInfo.packageName,
                        packageInfo.publicSourceDir,
                        packageInfo.flags and ApplicationInfo.FLAG_SYSTEM
                    )
                    Log.d("TestB","AppInfo ${app.appName}")
                    app.appIcon = packageInfo.loadIcon(packageManager)
                    if (packageInfo.flags and ApplicationInfo.FLAG_SYSTEM == 1 && !withSysApps) {
                        // checking if it is a system app.
                    } else {
                        try {
                            //count++;
                            // Get the list of permissions used by the application.
                            context?.let { context ->
                                context.createPackageContext(packageInfo.packageName, 0)
                                val appPermissionsList = getListOfPermissions(context)
                                // Get the list of intents used by the application.
                                val appIntentsList = getListOfIntents(
                                    context.createPackageContext(
                                        packageInfo.packageName,
                                        0
                                    )
                                )
                                var str: String
                                if (appPermissionsList.size == 0 && appIntentsList.size == 0) {
                                    app.prediction = context.getString(R.string.unknown)
                                    unknown.add(app)
                                }

                                // The following for loops are used to create the input feature vector
                                pJarray?.let { jsonArray ->
                                    for (i in 0 until jsonArray.length()) {
                                        str = jsonArray.optString(i)
                                        if (appPermissionsList.contains(str)) {
                                            inputVal[i] = 1f
                                            flag = true
                                        } else {
                                            inputVal[i] = 0f
                                        }
                                    }
                                }
                                iJarray?.let { jsonArray ->
                                    for (i in 0 until jsonArray.length()) {
                                        str = jsonArray.optString(i)
                                        if (appIntentsList.contains(str)) {
                                            inputVal[i + 489] = 1f
                                            flag = true
                                        } else {
                                            inputVal[i + 489] = 0f
                                        }
                                    }
                                }
                                if (!flag) {
                                    app.prediction = context.getString(R.string.unknown)
                                    unknown.add(app)
                                }

                                // To store output from the model
                                val outputVal = Array(1) { FloatArray(1) }

                                // Run the model
                                tflite?.run(inputVal, outputVal)

                                val inferredValue = outputVal[0][0]
                                app.predictionScore = inferredValue
                                app.permissionList = appPermissionsList
                                when {
                                    inferredValue > 0.75 -> {
                                        app.prediction = context.getString(R.string.malware)
                                        malware.add(app)
                                    }
                                    inferredValue > 0.5 -> {
                                        app.prediction = context.getString(R.string.risky)
                                        risky.add(app)
                                    }
                                    else -> {
                                        app.prediction = context.getString(R.string.safe)
                                        goodware.add(app)
                                    }
                                }
                            }
                        } catch (e: PackageManager.NameNotFoundException) {
                            e.printStackTrace()
                        }
                    }
                }
            }
    }

    private fun doOnSubscribe() {
        context?.let { context ->
            installedAppsCount = context.packageManager.getInstalledApplications(0).size
            notificationManager = NotificationManagerCompat.from(context)
            val notificationBuilder =
                NotificationCompat.Builder(context, ScannerTaskConstants.CHANNEL_ID)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val mChannel =
                    NotificationChannel(
                        ScannerTaskConstants.CHANNEL_ID,
                        ScannerTaskConstants.CHANNEL_NAME,
                        NotificationManager.IMPORTANCE_HIGH
                    )
                notificationManager?.createNotificationChannel(mChannel)
            }
            notificationBuilder.setSmallIcon(R.mipmap.ic_launcher_round)
                .setOngoing(true)
                .setContentTitle("Full Antivirus")
                .setContentText(contextReference!!.get()!!.getString(R.string.scanningApplications))
                .setProgress(0, 0, true)
            notificationManager?.notify(
                ScannerTaskConstants.NOTIFICATION_ID,
                notificationBuilder.build()
            )
        }
    }

    private fun mapToScannedApps(): ArrayList<AppInfo> {
        sharedPreferences
            ?.edit()
            ?.apply {
                putString(ExtensionUtils.WORK_STATUS, AppExtensionState.STOP.id)
                apply()
            }
        putDateInSharedPreference()

        val uri = ExtensionUtils.getContentUri(AppExtensionState.STOP.id)
        context?.contentResolver?.insert(uri, null)

        Collections.sort(malware, AppInfo.appNameComparator)
        Collections.sort(risky, AppInfo.appNameComparator)
        Collections.sort(unknown, AppInfo.appNameComparator)
        Collections.sort(goodware, AppInfo.appNameComparator)
        scannedApps.addAll(malware)
        scannedApps.addAll(risky)
        scannedApps.addAll(unknown)
        scannedApps.addAll(goodware)

        notificationManager?.cancel(ScannerTaskConstants.NOTIFICATION_ID)
        return scannedApps
    }

    var scanProgressObservable = PublishSubject.create<ScanProgressInfo>()

    private fun onScanProgress(scanStatus: String) {
        progressValue += 1
        val percentCompleted = (progressValue.toFloat() / installedAppsCount * 100f).toInt()
        val progressUri = ExtensionUtils.getProgressContentUri(percentCompleted.toString())
        context?.contentResolver?.insert(progressUri, null)

        val scanProgressInfo = ScanProgressInfo(
            scanStatus,
            String.format("%d of %d", progressValue, installedAppsCount),
            progressValue,
            percentCompleted
        )
        scanProgressObservable.onNext(scanProgressInfo)
    }

    private fun loadJSONFromAsset(): String? {
        return try {
            val jsonAsset = contextReference!!.get()!!.assets.open("features.json")
            val size = jsonAsset.available()
            val buffer = ByteArray(size)
            jsonAsset.read(buffer)
            jsonAsset.close()
            String(buffer, Charset.forName("UTF-8"))
        } catch (ex: IOException) {
            ex.printStackTrace()
            return null
        }
    }

    private fun loadModelFile(): MappedByteBuffer? {
        return try {
            context?.assets?.openFd("saved_model.tflite")?.let { fileDescriptor ->
                val inputStream = FileInputStream(fileDescriptor.fileDescriptor)
                val fileChannel = inputStream.channel
                val startOffset = fileDescriptor.startOffset
                val declaredLength = fileDescriptor.declaredLength
                fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength)
            }
        } catch (exception: Exception) {
            exception.printStackTrace()
            null
        }
    }

    private fun getListOfPermissions(context: Context): ArrayList<String> {
        val arr = ArrayList<String>()
        try {
            val am = context.createPackageContext(context.packageName, 0).assets
            val addAssetPath = am.javaClass.getMethod(
                "addAssetPath",
                String::class.java
            )
            val cookie = addAssetPath.invoke(
                am,
                context.packageManager.getApplicationInfo(context.packageName, 0).sourceDir
            ) as Int
            val xmlParser = am.openXmlResourceParser(cookie, "AndroidManifest.xml")
            var eventType = xmlParser.next()
            while (eventType != XmlPullParser.END_DOCUMENT) {
                if (eventType == XmlPullParser.START_TAG && "uses-permission" == xmlParser.name) {
                    for (i in 0 until xmlParser.attributeCount) {
                        if (xmlParser.getAttributeName(i) == "name") {
                            arr.add(xmlParser.getAttributeValue(i))
                        }
                    }
                }
                eventType = xmlParser.next()
            }
            xmlParser.close()
        } catch (exception: Exception) {
            exception.printStackTrace()
        }
        return arr
    }

    private fun getListOfIntents(context: Context): ArrayList<String> {
        val arr = ArrayList<String>()
        try {
            val am = context.createPackageContext(context.packageName, 0).assets
            val addAssetPath = am.javaClass.getMethod(
                "addAssetPath",
                String::class.java
            )
            val cookie = addAssetPath.invoke(
                am,
                context.packageManager.getApplicationInfo(context.packageName, 0).sourceDir
            ) as Int
            val xmlParser = am.openXmlResourceParser(cookie, "AndroidManifest.xml")
            var eventType = xmlParser.next()
            while (eventType != XmlPullParser.END_DOCUMENT) {
                if (eventType == XmlPullParser.START_TAG && "action" == xmlParser.name) {
                    for (i in 0 until xmlParser.attributeCount) {
                        if (xmlParser.getAttributeName(i) == "name") {
                            arr.add(xmlParser.getAttributeValue(i))
                        }
                    }
                }
                eventType = xmlParser.next()
            }
            xmlParser.close()
        } catch (exception: Exception) {
            exception.printStackTrace()
        }
        return arr
    }

    private fun putDateInSharedPreference() {
        sharedPreferences
            ?.edit()
            ?.apply {
                val curDateTime = DateFormat.getDateTimeInstance().format(Date())
                putString("lastScan", curDateTime)
                apply()
            }
    }
}